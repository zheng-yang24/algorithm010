### 学习笔记

#### 异或操作的一些特点：
x^0 = x
x ^ 1s=~x // 注意 1s=~0 (简称 全1)
x^(~x)=1s
x^x=0
c = a^b => a^c=b,b^c=a      // 交换两个数
a^b^c = a^(b^c)=(a^b)^c     // 乘法交换律

#### 指定位置的位运算：
    1、将x最右边的n位清零：x & (~0<<n)
    2、获取x的第n位值 (0或者1)：(x>>n)&1
    3、获取x的第n位的幂值：x&(1<<n)
    4、仅将第n位置为1：x|(1<<n)
    5、仅将第n位置为0：x&(~(1<<n))
    6、将x最高位至第n位(含)清零：x&((1<<n)-1)

#### 实战位运算要点
    1、判断奇偶
        x%2 == 1 -> (x&1) == 1
        x%2 == 0 -> (x&1) == 0
    2、x >> 1 -> x/2
        即： x=x/2; -> x = x >>1
         mid = (left+right)/2 -> mid=(left+right) >> 1
    3、x=x&(x-1) 清零最低位的1
    4、x & -x => 得到最低位1
    5、x&~x => 0
    
 #### 布隆过滤器
     它由一个bit数组和一组Hash算法构成。可用于判断一个元素是否在一个集合中，查询效率很高（1-N，最优能逼近于1）
     一个很长的 二进制向量和一系列随机映射函数。布隆过滤器用于检索一个元素是否在一个集合中
     优点：
         空间效率和查询时间都远远超过一般算法
     缺点：
         有一定的误识别率和删除困难
         
 #### 排序
      1、比较类排序
          时间复杂度不能突破 O(nlogn)
          交换排序
          插入排序
          选择排序
          归并排序
      2、非比较类排序
          对于整型
          可以达到 O(n+k)
          计数排序
          桶排序
              与计数排序的区别，计数排序是对应的下标是有序的连续的下标的桶排序
              桶排序是有一个函数要计算桶的下标，可以理解为计数排序的升级版
          基数排序
          
 ##### 初级排序
    1.选择排序
    
    ```php
    function selectSort($arr) {
        //双重循环完成，外层控制轮数，内层控制比较次数
        $len=count($arr);
        for($i=0; $i<$len-1; $i++) {
            //先假设最小的值的位置
            $p = $i;
            for($j=$i+1; $j<$len; $j++) {
                //$arr[$p] 是当前已知的最小值
                if($arr[$p] > $arr[$j]) {
                    //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。
                    $p = $j;
                }
            }
            //已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。
            if($p != $i) {
                $tmp = $arr[$p];
                $arr[$p] = $arr[$i];
                $arr[$i] = $tmp;
            }
        }
        return $arr;
    }
    ```
    
    2.插入排序
    
    ```php
    function insert_sort($arr) {
        $count = count($arr);
        //外层循环用于从未排序区域中取出待排序元素
        for ($i=1; $i < $count; $i++) {
            //获取当前需要插入已排序区域的元素值
            $temp = $arr[$i];
            //内层循环用于从已排序区域寻找待排序元素的插入位置
            for ($j=$i-1; $j >= 0; $j--) {
                //如果$arr[$i]比已排序区域的$arr[$j]小，就后移$arr[$j]
                if ($temp < $arr[$j]) {
                    $arr[$j+1] = $arr[$j];
                    $arr[$j] = $temp;
                } else {
                    //如果$arr[$i]不小于$arr[$j]，则对已排序区无需再排序
                    break;
                }
            }
        }
        return $arr;
    }
    ```
    
    3.冒泡排序
    
    ```php
    function MySort($arr){
        $length = count($arr);
        for($i = 0;$i < $length - 1;$i ++){
            for($j = $i + 1;$j < $length;$j ++){
                //将小的关键字放前面
                if($arr[$i] > $arr[$j]){
                    $temp = $arr[$i];
                    $arr[$i] = $arr[$j];
                    $arr[$j] = $temp;
                }
            }
        }
    }
    ```